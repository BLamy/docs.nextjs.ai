import { Callout } from 'nextra-theme-docs'

# Zod Validation
Zod is a typescript library that allows you to define a schema for your types. 
The difference between zod and typescript is that zod allows you to validate data at runtime instead of just providing static analysis a build time.
Zod will also allow you to make assertions that are difficult to make in typescript such as number max and mins. 
```typescript filename="./src/ai/prompts/NumberGenerator.Prompt.ts"
import { z } from 'zod';
const inputSchema = z.object({
  min: z.number().min(1).max(100),
  max: z.number().min(1).max(100),
});
const outputSchema = z.object({
  result: z.number().min(1).max(100),
});
export type Prompt = "Can you tell me a number between {{min}} and {{max}}?"
export type Input = z.infer<typeof inputSchema>
export type Output = z.infer<typeof outputSchema>
export type Errors = "max must be greater than min" | "json parse error" | "zod validation error" 
```

This will allow you to double check the inputs and outputs at runtime.  

```typescript filename="./src/app/api/NumberGenerator.ts"
import { inputSchema, outputSchema } from '@/ai/prompts/NumberGenerator.Prompt';

export const config = {
  runtime: 'edge'
}

export default async function handler(req: Request) {
  const input = inputSchema.parse(req.body);

  const response = await openai.createChatCompletion({ 
    model: "gpt-4",
    messages: [
      {
      role: "system",
      content: process.env.NumberGeneratorPrompt,
      },
      {
        role: "user",
        content: JSON.stringify(input),
      },
    ]
  });

  const output = outputSchema.parse(JSON.parse(response.data.choices[0].text));

  return new Response(output);
}
```


<Callout type="error" emoji="ðŸš«">
If either the input or output is invalid, the request will fail with a 400 error.
</Callout>


### Example
```typescript filename="./src/ai/prompts/JokeGenerator.Prompt.ts"
// ### Examples
// USER: { "count": 3, "jokeType": "funny" }
// ASSISTANT: [
//   { "setup": "Why did the tomato turn red?", "punchline": "Because it saw the salad dressing!", "explanation": "This is a funny joke because of the pun in salad dressing."  },
//   { "setup": "Why did the scarecrow win an award?", "punchline": "Because he was outstanding in his field.", "explanation": "This is a funny joke because of the pun on the word field."  },
//   { "setup": "Why don't scientists trust atoms?", "punchline": "Because they make up everything.", "explanation": "This is a funny joke because atoms are the basic building block for everything and therefore there is a pun for making everything up"  }
// ]

// ### Typescript
import { z } from 'zod';

const jokeTypeSchema = z.union([
    z.literal("funny"),
    z.literal("dumb"),
    z.literal("dad"),
]);

export const inputSchema = z.object({
  count: z.number().min(1).max(10),
  jokeType: jokeTypeSchema,
});

export const outputSchema = z.array(
  z.object({
      setup: z.string(),
      punchline: z.string(),
      // explanation should match the pattern: This is a {{jokeType}} joke because {{reason}}
      explanation: z.string().refine(value => new RegExp(/This is a (funny|dad|dumb) joke (.*)/).test(value), {
        message: 'explanation should match the pattern: This is a {{jokeType}} joke because {{reason}}',
      })
    })
)

export type Prompt = "Can you tell {{count}} {{jokeType}} jokes?"
export type Input = z.infer<typeof inputSchema>
export type Output = z.infer<typeof outputSchema>
```